// Generated by CoffeeScript 1.9.3
(function() {
  var assert, caculate_metric, dgram, gateways, http, regions, reset_route, route_metric, send_route, sequence, server, server_id, server_port, servers, socket, timeout, timeout_timer, update_route, updating,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  dgram = require('dgram');

  assert = require('assert');

  http = require('http');

  server_port = 495;

  timeout = 10;

  regions = [
    {
      id: 0,
      name: "default"
    }, {
      id: 1,
      name: "ap"
    }, {
      id: 2,
      name: "cn"
    }
  ];

  gateways = {
    2: {
      2: {
        server_id: 2,
        region_id: 2,
        delay: 0,
        jitter: 0,
        reliability: 1
      }
    },
    3: {
      0: {
        server_id: 3,
        region_id: 0,
        delay: 0.1,
        jitter: 0,
        reliability: 1
      },
      1: {
        server_id: 3,
        region_id: 1,
        delay: 0,
        jitter: 0,
        reliability: 1
      }
    },
    4: {
      0: {
        server_id: 4,
        region_id: 0,
        delay: 0,
        jitter: 0,
        reliability: 1
      }
    },
    6: {
      2: {
        server_id: 6,
        region_id: 2,
        delay: 0,
        jitter: 0,
        reliability: 1
      }
    },
    7: {
      0: {
        server_id: 7,
        region_id: 0,
        delay: 0.1,
        jitter: 0,
        reliability: 1
      },
      1: {
        server_id: 7,
        region_id: 1,
        delay: 0,
        jitter: 0,
        reliability: 1
      }
    }
  };

  servers = {
    2: {
      id: 2,
      inbound_cost: 0,
      outbound_cost: 0.8
    },
    3: {
      id: 3,
      inbound_cost: 0,
      outbound_cost: 0.05
    },
    4: {
      id: 4,
      inbound_cost: 0,
      outbound_cost: 0.03
    },
    6: {
      id: 6,
      inbound_cost: 0,
      outbound_cost: 0.8
    },
    7: {
      id: 7,
      inbound_cost: 0,
      outbound_cost: 1
    }
  };

  sequence = 0;

  updating = null;

  timeout_timer = null;

  socket = dgram.createSocket('udp4');

  caculate_metric = function(delay, jitter, reliability, cost) {
    assert(jitter >= 0);
    assert((0 <= reliability && reliability <= 1), "reliability: " + reliability);
    assert(cost >= 0);
    return delay + (1 - reliability) * 6 + cost * 0.1;
  };

  route_metric = function(server_id, from, to, next_hop) {
    var current, delay, external_cost, external_jitter, external_reliability, internal_cost, internal_jitter, internal_reliability, next, quality, route;
    delay = 0;
    internal_reliability = 1;
    internal_jitter = 0;
    internal_cost = 0;
    external_reliability = 1;
    external_jitter = 0;
    external_cost = 0;
    current = server_id;
    next = next_hop;
    route = [current, next];
    while (true) {
      if (next === 0) {
        assert(from !== 0);
        quality = gateways[current][to];
        if (!quality || quality.reliability <= 0) {
          return Number.POSITIVE_INFINITY;
        }
        delay += quality.delay;
        external_reliability *= Math.sqrt(quality.reliability);
        external_jitter += quality.jitter / 2;
        external_cost += servers[current].outbound_cost;
        internal_reliability *= Math.sqrt(quality.reliability);
        internal_jitter += quality.jitter / 2;
        internal_cost += servers[current].inbound_cost;
        if (current === from) {
          return caculate_metric(delay, internal_jitter + external_jitter, internal_reliability * external_reliability, internal_cost + external_cost);
        }
        next = servers[current].routes[0][from];
        route = [current, next];
        while (true) {
          quality = servers[next].quality[current];
          if (!quality || quality.reliability <= 0) {
            return Number.POSITIVE_INFINITY;
          }
          delay += quality.delay;
          internal_jitter += quality.jitter;
          internal_reliability *= quality.reliability;
          internal_cost += servers[current].outbound_cost + servers[next].inbound_cost;
          if (next === from) {
            return caculate_metric(delay, internal_jitter + external_jitter, internal_reliability * external_reliability, internal_cost + external_cost);
          } else {
            current = next;
            next = servers[current].routes[0][from];
            assert(next != null);
            if (indexOf.call(route, next) >= 0) {
              return Number.POSITIVE_INFINITY;
            } else {
              route.push(next);
            }
          }
        }
      } else {
        quality = servers[next].quality[current];
        if (!quality || quality.reliability <= 0) {
          return Number.POSITIVE_INFINITY;
        }
        delay += quality.delay;
        if (from === 0) {
          internal_reliability *= quality.reliability;
          internal_jitter += quality.jitter;
          internal_cost += servers[current].outbound_cost + servers[next].inbound_cost;
          if (next === to) {
            return caculate_metric(delay, internal_jitter + external_jitter, internal_reliability * external_reliability, internal_cost + external_cost);
          }
        } else {
          external_reliability *= quality.reliability;
          external_jitter += quality.jitter;
          external_cost += servers[current].outbound_cost + servers[next].inbound_cost;
        }
        current = next;
        next = servers[current].routes[from][to];
        if (next != null) {
          if (indexOf.call(route, next) >= 0) {
            return Number.POSITIVE_INFINITY;
          } else {
            route.push(next);
          }
        } else {
          assert(from !== 0);
          return Number.POSITIVE_INFINITY;
        }
      }
    }
  };

  update_route = function(server, from, to) {
    var best_metric, best_next_hop, current_metric, current_next_hop, index, metric, next_hop_server, now;
    current_next_hop = server.routes[from][to];
    if (current_next_hop != null) {
      current_metric = route_metric(server.id, from, to, current_next_hop);
    } else {
      assert(from !== 0);
      current_metric = Number.POSITIVE_INFINITY;
    }
    best_next_hop = current_next_hop;
    best_metric = current_metric;
    for (index in servers) {
      next_hop_server = servers[index];
      if (!(next_hop_server.id !== current_next_hop && next_hop_server !== server && next_hop_server.id !== from)) {
        continue;
      }
      metric = route_metric(server.id, from, to, next_hop_server.id);
      if (metric < best_metric) {
        best_next_hop = next_hop_server.id;
        best_metric = metric;
      }
    }
    if (from !== 0) {
      metric = route_metric(server.id, from, to, 0);
      if (metric < best_metric) {
        best_next_hop = 0;
        best_metric = metric;
      }
    }
    now = new Date().getTime() / 1000;
    if (current_next_hop !== best_next_hop && (current_metric === Number.POSITIVE_INFINITY || (current_metric - best_metric - 0.01) * (now - server.updated_at[from][to]) > 10)) {
      console.log("update #" + sequence + ": server" + server.id + " from " + from + " to " + to + " next hop " + current_next_hop + "(" + current_metric + ") -> " + best_next_hop + "(" + best_metric + ")");
      server.routes[from][to] = best_next_hop;
      server.updated_at[from][to] = now;
      updating = setInterval(function() {
        return send_route(server, from, to, best_next_hop);
      }, 1000);
      send_route(server, from, to, best_next_hop);
      timeout_timer = setTimeout(function() {
        delete server.address;
        delete server.port;
        clearInterval(updating);
        updating = null;
        return console.log("server" + server.id + " lost connection.");
      }, timeout * 1000);
      return true;
    }
    return false;
  };

  send_route = function(server, from, to, next_hop) {
    var gateway, message;
    message = {
      sequence: sequence,
      from: from,
      to: to,
      next_hop: next_hop
    };
    if (server === from) {
      gateway = server;
      while (next_hop !== 0) {
        gateway = next_hop;
        next_hop = servers[gateway].routes[from][to];
      }
      message.gateway = gateway;
    }
    message = JSON.stringify(message);
    return socket.send(message, 0, message.length, server.port, server.address);
  };

  reset_route = function(server) {
    var i, now, region, region_id, results, s;
    now = new Date().getTime() / 1000;
    server.quality = {};
    server.routes = {};
    server.updated_at = {};
    server.routes[0] = {};
    server.updated_at[0] = {};
    results = [];
    for (i in servers) {
      s = servers[i];
      server.routes[0][i] = parseInt(i);
      server.updated_at[0][i] = now;
      server.routes[i] = {};
      server.updated_at[i] = {};
      results.push((function() {
        var results1;
        results1 = [];
        for (region_id in regions) {
          region = regions[region_id];
          if (!((gateways[server.id] != null) && (gateways[server.id][region_id] != null))) {
            continue;
          }
          server.routes[i][region_id] = 0;
          results1.push(server.updated_at[i][region_id] = now);
        }
        return results1;
      })());
    }
    return results;
  };

  socket.on('message', function(message, rinfo) {
    var from, j, len, region, server, server_id, to;
    message = JSON.parse(message);
    server = servers[message.server_id];
    if (server == null) {
      return;
    }
    if (server.address !== rinfo.address || server.port !== rinfo.port) {
      server.address = rinfo.address;
      server.port = rinfo.port;
      console.log("server " + server.id + " connected from " + server.address + ":" + server.port);
      reset_route(server);
    }
    server.quality = message.quality;
    if ((updating != null) && message.acknowledgement === sequence) {
      clearInterval(updating);
      clearTimeout(timeout_timer);
      updating = null;
      sequence += 1;
    }
    if (updating == null) {
      for (server_id in servers) {
        server = servers[server_id];
        if (!(server.address != null)) {
          continue;
        }
        for (to in servers) {
          if (to !== server_id) {
            if (update_route(server, 0, parseInt(to))) {
              return;
            }
          }
        }
        for (from in servers) {
          for (j = 0, len = regions.length; j < len; j++) {
            region = regions[j];
            if (update_route(server, parseInt(from), region.id)) {
              return;
            }
          }
        }
      }
    }
  });

  for (server_id in servers) {
    server = servers[server_id];
    reset_route(server);
  }

  socket.bind(server_port);

  http.createServer(function(req, res) {
    res.writeHead(200, {
      'Content-Type': 'application/json'
    });
    return res.end(JSON.stringify(servers));
  }).listen(server_port);

}).call(this);

//# sourceMappingURL=main.js.map
